#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/fb.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <string.h>

// Define the framebuffer device path
#define FRAMEBUFFER_DEVICE "/dev/fb0"

static int fb_fd;
static struct fb_var_screeninfo vinfo;
static struct fb_fix_screeninfo finfo;
static char *fb_ptr;

// A basic 5x7 font for ASCII characters 32-126
const uint8_t font[96][7] = {
    // Each row defines a 5x7 grid of a character (add more for all 96 supported ASCII chars)
    [0] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Placeholder for space
    // Define other characters here
};

// Initialize the framebuffer
void initialize_framebuffer() {
    fb_fd = open(FRAMEBUFFER_DEVICE, O_RDWR);
    if (fb_fd < 0) {
        perror("Error opening framebuffer device");
        exit(EXIT_FAILURE);
    }

    if (ioctl(fb_fd, FBIOGET_VSCREENINFO, &vinfo)) {
        perror("Error reading variable screen info");
        close(fb_fd);
        exit(EXIT_FAILURE);
    }

    if (ioctl(fb_fd, FBIOGET_FSCREENINFO, &finfo)) {
        perror("Error reading fixed screen info");
        close(fb_fd);
        exit(EXIT_FAILURE);
    }

    size_t screensize = vinfo.yres_virtual * finfo.line_length;
    fb_ptr = (char *)mmap(0, screensize, PROT_READ | PROT_WRITE, MAP_SHARED, fb_fd, 0);
    if (fb_ptr == MAP_FAILED) {
        perror("Error mapping framebuffer to memory");
        close(fb_fd);
        exit(EXIT_FAILURE);
    }
}

// Clear the framebuffer to a specific color
void clear_screen(uint32_t color) {
    for (unsigned int y = 0; y < vinfo.yres; y++) {
        for (unsigned int x = 0; x < vinfo.xres; x++) {
            size_t location = (x + vinfo.xoffset) * (vinfo.bits_per_pixel / 8) +
                              (y + vinfo.yoffset) * finfo.line_length;
            if (vinfo.bits_per_pixel == 32) {
                *((uint32_t *)(fb_ptr + location)) = color;
            }
        }
    }
}

// Draw a single pixel
void draw_pixel(unsigned int x, unsigned int y, uint32_t color) {
    size_t location = (x + vinfo.xoffset) * (vinfo.bits_per_pixel / 8) +
                      (y + vinfo.yoffset) * finfo.line_length;
    if (vinfo.bits_per_pixel == 32) {
        *((uint32_t *)(fb_ptr + location)) = color;
    }
}

// Draw a box
void draw_box(unsigned int x_start, unsigned int y_start, unsigned int width, unsigned int height, uint32_t color) {
    for (unsigned int y = y_start; y < y_start + height; y++) {
        for (unsigned int x = x_start; x < x_start + width; x++) {
            if (x == x_start || x == x_start + width - 1 || y == y_start || y == y_start + height - 1) {
                draw_pixel(x, y, color);
            }
        }
    }
}

// Draw a character using the font
void draw_character(unsigned int x, unsigned int y, char c, uint32_t color) {
    if (c < 32 || c > 126) return; // Skip unsupported characters

    const uint8_t *glyph = font[c - 32];
    for (int row = 0; row < 7; row++) {
        for (int col = 0; col < 5; col++) {
            if (glyph[row] & (1 << (4 - col))) { // Check bit
                draw_pixel(x + col, y + row, color);
            }
        }
    }
}

// Draw a string of characters
void draw_string(unsigned int x, unsigned int y, const char *str, uint32_t color) {
    while (*str) {
        draw_character(x, y, *str++, color);
        x += 6; // Move to the next character
    }
}

// Draw the main blocks
void draw_main_blocks() {
    unsigned int border = 50; // Outer buffer for the entire window
    unsigned int main_width = vinfo.xres - 2 * border;
    unsigned int main_height = vinfo.yres - 2 * border;

    // Draw main window border
    draw_box(border, border, main_width, main_height, 0xFFFFFF);

    // Inner padding within the main window
    unsigned int inner_padding = 20; // Space between main window edges and inner content

    // Calculate available drawing area inside the main window
    unsigned int inner_width = main_width - 2 * inner_padding;
    unsigned int inner_height = main_height - 2 * inner_padding;

    // Calculate dimensions of each block
    unsigned int block_width = (inner_width - inner_padding) / 2;
    unsigned int block_height = (inner_height - inner_padding) / 3;

    // Labels for each block
    const char *labels[6] = {"1) CPU", "2) Memory", "3) Disk", "4) Network", "5) Power", "6) I/O"};

    // Draw each block and its label
    for (int i = 0; i < 6; i++) {
        // Determine position of each block
        unsigned int x_start = border + inner_padding + (i % 2) * (block_width + inner_padding);
        unsigned int y_start = border + inner_padding + (i / 2) * (block_height + inner_padding);

        // Draw block
        draw_box(x_start, y_start, block_width, block_height, 0xFFFFFF);

        // Position label inside the block, centered horizontally and with some vertical padding
        unsigned int label_x = x_start + (block_width / 2) - (strlen(labels[i]) * 3); // Centered horizontally
        unsigned int label_y = y_start + (block_height / 2) - 3; // Centered vertically

        // Draw label
        draw_string(label_x, label_y, labels[i], 0xFFFFFF);
    }
}

// Persistent display loop
void run_persistent_display() {
    while (1) {
        clear_screen(0x000000); // Clear to black
        draw_main_blocks();
        sleep(1); // Refresh every second
    }
}

int main() {
    initialize_framebuffer();
    run_persistent_display();

    munmap(fb_ptr, vinfo.yres_virtual * finfo.line_length);
    close(fb_fd);
    return 0;
}

